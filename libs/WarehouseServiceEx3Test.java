/**
 * Copyright (c) 2024 Araf Karsh Hamid
 * <p>
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * <p>
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * <p>
 * This program and the accompanying materials are dual-licensed under
 * either the terms of the Eclipse Public License v1.0 as published by
 * the Eclipse Foundation
 * <p>
 * or (per the licensee's choosing)
 * <p>
 * under the terms of the Apache 2 License version 2.0
 * as published by the Apache Software Foundation.
 */
package test.fusion.water.order.copilot.mockito3;

import static java.lang.invoke.MethodHandles.lookup;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;
import static org.slf4j.LoggerFactory.getLogger;

import java.util.ArrayList;
import java.util.List;

import io.fusion.water.order.domain.models.*;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Spy;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;

import io.fusion.water.order.adapters.service.OrderServiceImpl;
import io.fusion.water.order.adapters.service.PackingServiceImpl;
import io.fusion.water.order.adapters.service.WarehouseServiceImpl;
import io.fusion.water.order.domain.services.PaymentService;
import io.fusion.water.order.domain.services.ShippingService;
import test.fusion.water.order.junit.junit5.annotations.tests.Critical;
import test.fusion.water.order.junit.junit5.annotations.tests.Functional;
import test.fusion.water.order.junit.junit5.annotations.tools.Mockito3;
import test.fusion.water.order.junit.junit5.extensions.TestTimeExtension;
import io.fusion.water.order.domain.services.OrderRepository;

/**
 * ms-test-quickstart / WarehouseServiceEx3Test
 * Code Autogenerated by GitHub CoPilot
 * Prompt:
 * Create a complete test code (with import statements) to test the WarehouseServiceImpl.
 * 1. Ensure the Multiple set of orders are created with ORDER_PACKED status for the shipment
 *    and some with Order in Preparing stage.
 * 2. Similarly after the packaging the Order Status must in READY_FOR_SHIPMENT.
 * 3. Once the Warehouse.shipOrder() is called the Order Status must be IN_TRANSIT.
 * 4. Create both positive and negative test cases for the above scenarios. Like Sending Order
 *    waiting for payment to Ship
 *
 * @author: CoPilot, Araf Karsh Hamid
 * @version: 0.1
 * @date: 2024-12-24T11:35 AM
 */
@Mockito3()
@Critical()
@Functional()
@TestMethodOrder(OrderAnnotation.class)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@ExtendWith(TestTimeExtension.class)
@ExtendWith(MockitoExtension.class)
public class WarehouseServiceEx3Test {

    static final Logger log = getLogger(lookup().lookupClass());

    private ArrayList<OrderEntity> orderList;
    private ArrayList<OrderEntity> orderReadyList;
    private int counter = 1;

    @Spy
    PackingServiceImpl packingService;

    @Mock
    ShippingService shippingService;

    @InjectMocks
    WarehouseServiceImpl warehouseService;

    @Mock
    OrderRepository orderRepo;

    @Mock
    PaymentService paymentService;

    @InjectMocks
    OrderServiceImpl orderService;

    @BeforeAll
    public void setupAll() {
        System.out.println("== Warehouse Mock Suite Execution Started...");
    }

    @BeforeEach
    public void setup() {
        System.out.println(counter + ". Create Order List");
        orderList = createOrder();
        orderReadyList = new ArrayList<OrderEntity>();
    }

    @Test
    @DisplayName("1.1 Test Orders Ready for Shipment")
    @Order(1)
    @Tag("critical")
    void testOrdersReadyForShipment() {
        // Given Orders are Packed
        for (OrderEntity order : orderList) {
            order.orderPacked();
        }
        when(packingService.packOrders(orderList)).thenReturn(orderList);

        // When Orders are Processed
        List<OrderEntity> processedOrders = warehouseService.processOrders(orderList);

        // Then Orders should be Ready for Shipment
        for (OrderEntity order : processedOrders) {
            assertEquals(OrderStatus.READY_FOR_SHIPMENT, order.getOrderStatus());
        }
    }

    @Test
    @DisplayName("1.2 Test Orders In Transit")
    @Order(2)
    @Tag("critical")
    void testOrdersInTransit() {
        // Given Orders are Ready for Shipment
        for (OrderEntity order : orderList) {
            order.orderReadyForShipment();
        }
        // when(shippingService.shipOrder(orderList)).thenReturn(orderList);

        // When Orders are Shipped
        List<OrderEntity> shippedOrders = warehouseService.processOrders(orderList);

        // Then Orders should be In Transit
        for (OrderEntity order : shippedOrders) {
            assertEquals(OrderStatus.IN_TRANSIT, order.getOrderStatus());
        }
    }

    @Test
    @DisplayName("1.3 Test Orders Waiting for Payment")
    @Order(3)
    @Tag("negative")
    void testOrdersWaitingForPayment() {
        // Given Orders are Waiting for Payment
        for (OrderEntity order : orderList) {
            order.orderWaitingForPayment();
        }

        // When Orders are Processed
        List<OrderEntity> processedOrders = warehouseService.processOrders(orderList);

        // Then Orders should not be Shipped
        for (OrderEntity order : processedOrders) {
            assertEquals(OrderStatus.PAYMENT_EXPECTED, order.getOrderStatus());
        }
    }

    @AfterEach
    public void tearDown() {
        counter++;
        printLogs(orderReadyList);
    }

    @AfterAll
    public void tearDownAll() {
        System.out.println("== Warehouse Mock Suite Execution Completed...");
    }

    public void printLogs(ArrayList<OrderEntity> orderList) {
        for (OrderEntity order : orderList) {
            System.out.println("id=" + order.getOrderId() + "|st=" + order.getOrderStatus());
        }
    }

    public static ArrayList<OrderEntity> createOrder() {
        ArrayList<OrderEntity> orderList = new ArrayList<OrderEntity>();
        orderList.add(new OrderEntity.Builder()
                .addCustomer(new Customer("UUID", "John", "Doe", "0123456789"))
                .addOrderItem(new OrderItem("uuid1", "iPhone 12", 799, "USD", 1))
                .addOrderItem(new OrderItem("uuid2", "iPhone 12 Pro", 999, "USD", 1))
                .addOrderItem(new OrderItem("uuid3", "Apple Watch Series 6", 450, "USD", 2))
                .addShippingAddress(new ShippingAddress("321 Cobblestone Ln,", "", "Edison", "NJ", "", "USA", "08820"))
                .addPaymentType(PaymentType.CREDIT_CARD)
                .addCardDetails(new CardDetails("1234 5678 9876 5432", "John Doe", 7, 2025, 456, CardType.MASTER))
                .waitingForPayment()
                .build());

        orderList.add(new OrderEntity.Builder()
                .addCustomer(new Customer("UUID", "Jane", "Doe", "0123456789"))
                .addOrderItem(new OrderItem("uuid2", "iPhone 12 Pro Max", 1199, "USD", 1))
                .addOrderItem(new OrderItem("uuid3", "Apple Watch Series 6", 450, "USD", 2))
                .addShippingAddress(new ShippingAddress("323 Cobblestone Ln,", "", "Edison", "NJ", "", "USA", "08820"))
                .addPaymentType(PaymentType.DEBIT_CARD)
                .addCardDetails(new CardDetails("1234 5678 9876 5432", "John Doe", 7, 2025, 456, CardType.MASTER))
                .waitingForPayment()
                .build());

        orderList.add(new OrderEntity.Builder()
                .addCustomer(new Customer("UUID", "Ann", "Doe", "0123456789"))
                .addOrderItem(new OrderItem("uuid2", "iPhone 12 Mini", 699, "USD", 1))
                .addOrderItem(new OrderItem("uuid3", "Apple Watch Series 6", 450, "USD", 2))
                .addShippingAddress(new ShippingAddress("323 Cobblestone Ln,", "", "Edison", "NJ", "", "USA", "08820"))
                .addPaymentType(PaymentType.GOOGLE_PAY)
                .addCardDetails(new CardDetails("1234 5678 9876 5432", "John Doe", 7, 2025, 456, CardType.MASTER))
                .waitingForPayment()
                .build());

        return orderList;
    }
}
